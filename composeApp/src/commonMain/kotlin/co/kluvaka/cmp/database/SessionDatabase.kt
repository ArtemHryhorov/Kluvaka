package co.kluvaka.cmp.database

import co.kluvaka.cmp.features.sessions.domain.model.Session
import co.kluvaka.cmp.features.sessions.domain.model.Rod
import co.kluvaka.cmp.features.sessions.domain.model.FishingSessionEvent
import co.kluvaka.cmp.features.sessions.domain.model.FishingSessionEventType
import kotlinx.serialization.json.Json
import kotlinx.serialization.encodeToString

class SessionDatabase(databaseDriverFactory: DatabaseDriverFactory) {
  private val database = AppDatabase(databaseDriverFactory.createDriver())
  private val dbQuery = database.sessionQueries

  fun insertSessionWithRods(session: Session) {
    // Insert the main session record first.
    // The 'id' is generated by the database upon insertion.
    dbQuery.insertSession(
      location = session.location,
      date = session.dateMillis,
      isActive = if (session.isActive) 1 else 0,
    )

    // Get the ID of the newly inserted session.
    // We can't access the last inserted ID directly in this query.
    // So we will select it in a next step.
    // Here we are assuming there's a function or mechanism to get the last inserted ID.
    val sessionId = dbQuery.lastInsertRowId().executeAsOne()

    // Iterate through the rods in the session and insert each one.
    session.rods.forEach { rod ->
      dbQuery.insertRod(
        sessionId = sessionId,
        order = rod.order.toLong(),
        distance = rod.distance.toLong(),
        bait = rod.bait
      )
    }
  }

  fun getSessionWithRods(sessionId: Int): Session {
    val session = dbQuery.getAllSessions().executeAsList()
      .first { it.id.toInt() == sessionId }

    val rods = dbQuery.getRodsBySession(sessionId.toLong()).executeAsList()
      .map {
        Rod(
          order = it.order.toInt(),
          distance = it.distance.toInt(),
          bait = it.bait,
        )
      }

    val events = getEventsBySession(sessionId)

    return Session(
      id = session.id.toInt(),
      location = session.location,
      dateMillis = session.date,
      rods = rods,
      isActive = session.isActive == 1L,
      events = events,
    )
  }

  fun getAllSessionsWithRods(): List<Session> {
    return dbQuery.getAllSessions()
      .executeAsList()
      .map { session ->
        val rods = dbQuery.getRodsBySession(session.id)
          .executeAsList()
          .map {
            Rod(
              order = it.order.toInt(),
              distance = it.distance.toInt(),
              bait = it.bait
            )
          }

        val events = getEventsBySession(session.id.toInt())

        Session(
          id = session.id.toInt(),
          location = session.location,
          dateMillis = session.date,
          rods = rods,
          isActive = session.isActive == 1L,
          events = events,
        )
      }
  }

  fun updateSession(session: Session) {
    dbQuery.updateSession(
      id = session.id?.toLong() ?: 0,
      location = session.location,
      date = session.dateMillis,
      isActive = if (session.isActive) 1L else 0L,
    )
  }

  fun getEventsBySession(sessionId: Int): List<FishingSessionEvent> {
    return dbQuery.getEventsBySession(sessionId.toLong()).executeAsList()
      .map { eventRow ->
        val eventType = when (eventRow.event_type) {
          "FISH" -> FishingSessionEventType.Fish(eventRow.rod_id?.toInt() ?: 0)
          "LOOSE" -> FishingSessionEventType.Loose(eventRow.rod_id?.toInt() ?: 0)
          "SPOMB" -> FishingSessionEventType.Spomb(eventRow.count?.toInt() ?: 0)
          else -> throw IllegalArgumentException("Unknown event type: ${eventRow.event_type}")
        }

        val photos = if (eventRow.photos.isNullOrBlank()) {
          emptyList()
        } else {
          try {
            Json.decodeFromString<List<String>>(eventRow.photos)
          } catch (e: Exception) {
            emptyList()
          }
        }

        FishingSessionEvent(
          id = eventRow.id.toInt(),
          type = eventType,
          timestamp = eventRow.timestamp,
          weight = eventRow.weight,
          photos = photos,
          notes = eventRow.notes
        )
      }
  }

  fun insertEvent(sessionId: Int, event: FishingSessionEvent) {
    val (eventType, rodId, count) = when (event.type) {
      is FishingSessionEventType.Fish -> Triple("FISH", event.type.rodId.toLong(), null)
      is FishingSessionEventType.Loose -> Triple("LOOSE", event.type.rodId.toLong(), null)
      is FishingSessionEventType.Spomb -> Triple("SPOMB", null, event.type.count.toLong())
    }

    val photosJson = if (event.photos.isNotEmpty()) {
      Json.encodeToString(event.photos)
    } else {
      null
    }

    dbQuery.insertEvent(
      sessionId = sessionId.toLong(),
      eventType = eventType,
      rodId = rodId,
      count = count,
      timestamp = event.timestamp,
      weight = event.weight,
      photos = photosJson,
      notes = event.notes
    )
  }

  fun deleteSession(sessionId: Int) {
    dbQuery.deleteSession(id = sessionId.toLong())
  }

  fun getEventById(eventId: Int): FishingSessionEvent? {
    val eventRow = dbQuery.getEventById(id = eventId.toLong()).executeAsOneOrNull() ?: return null
    val eventType = when (eventRow.event_type) {
      "FISH" -> FishingSessionEventType.Fish(eventRow.rod_id?.toInt() ?: 0)
      "LOOSE" -> FishingSessionEventType.Loose(eventRow.rod_id?.toInt() ?: 0)
      "SPOMB" -> FishingSessionEventType.Spomb(eventRow.count?.toInt() ?: 0)
      else -> throw IllegalArgumentException("Unknown event type: ${eventRow.event_type}")
    }
    val photos = if (eventRow.photos.isNullOrBlank()) {
      emptyList()
    } else {
      try {
        Json.decodeFromString<List<String>>(eventRow.photos)
      } catch (_: Exception) {
        emptyList()
      }
    }
    return FishingSessionEvent(
      id = eventRow.id.toInt(),
      type = eventType,
      timestamp = eventRow.timestamp,
      weight = eventRow.weight,
      photos = photos,
      notes = eventRow.notes
    )
  }
}