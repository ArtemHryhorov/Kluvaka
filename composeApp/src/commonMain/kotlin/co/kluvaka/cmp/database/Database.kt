package co.kluvaka.cmp.database

import co.kluvaka.cmp.features.equipment.domain.model.Equipment
import co.kluvaka.cmp.features.sessions.domain.model.FishingSession
import co.kluvaka.cmp.features.sessions.domain.model.Rod

internal class Database(databaseDriverFactory: DatabaseDriverFactory) {
  private val database = AppDatabase(databaseDriverFactory.createDriver())
  private val dbQuery = database.appDatabaseQueries

  /*
  *
  *  Equipments queries
  *
  * */
  internal fun getAllEquipment(): List<Equipment> {
    return dbQuery.selectAllEquipment(::mapEquipment).executeAsList()
  }

  internal fun insertEquipment(equipment: Equipment) {
    dbQuery.transaction {
      dbQuery.insertEquipment(
        id = equipment.id.toLong(),
        title = equipment.title,
        image = equipment.image,
        price = equipment.price,
      )
    }
  }

  internal fun deleteEquipment(id: Int) {
    dbQuery.transaction {
      dbQuery.deleteEquipment(id.toLong())
    }
  }

  private fun mapEquipment(
    id: Long,
    title: String,
    image: String?,
    price: Double,
  ): Equipment {
    return Equipment(
      id = id.toInt(),
      title = title,
      image = image,
      price = price,
    )
  }


  /*
  *
  *  Fishing Sessions queries
  *
  * */
  fun insertSessionWithRods(session: FishingSession) {
    // Insert the main session record first.
    // The 'id' is generated by the database upon insertion.
    dbQuery.insertSession(location = session.location, date = session.date)

    // Get the ID of the newly inserted session.
    // We can't access the last inserted ID directly in this query.
    // So we will select it in a next step.
    // Here we are assuming there's a function or mechanism to get the last inserted ID.
    val sessionId = dbQuery.lastInsertRowId().executeAsOne()

    // Iterate through the rods in the session and insert each one.
    session.rods.forEach { rod ->
      dbQuery.insertRod(
        sessionId = sessionId,
        order = rod.order.toLong(),
        distance = rod.distance.toLong(),
        bait = rod.bait
      )
    }
  }

  fun getSessionWithRods(sessionId: Int): FishingSession {
    val session = dbQuery.getAllSessions().executeAsList()
      .first { it.id.toInt() == sessionId }

    val rods = dbQuery.getRodsBySession(sessionId.toLong()).executeAsList()
      .map {
        Rod(
          order = it.order.toInt(),
          distance = it.distance.toInt(),
          bait = it.bait,
        )
      }

    return FishingSession(
      id = session.id.toInt(),
      location = session.location,
      date = session.date,
      rods = rods
    )
  }

  fun getAllSessionsWithRods(): List<FishingSession> {
    return dbQuery.getAllSessions()
      .executeAsList()
      .map { session ->
        val rods = dbQuery.getRodsBySession(session.id)
          .executeAsList()
          .map {
            Rod(
              order = it.order.toInt(),
              distance = it.distance.toInt(),
              bait = it.bait
            )
          }

        FishingSession(
          id = session.id.toInt(),
          location = session.location,
          date = session.date,
          rods = rods
        )
      }
  }
}